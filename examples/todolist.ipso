not : Bool -> Bool
not a = if a then false else true

and : Bool -> Bool -> Bool
and a b = if a then b else false

strip : String -> String
strip = filterString (\c -> not (eqChar c '\n'))

deleteAt : Int -> Array a -> Array a
deleteAt target arr = 
  if ltInt target (lengthArray arr)
  then
    generateArray 
      (subtract (lengthArray arr) 1) 
      (\ix ->
        if ltInt ix target
        then indexArray ix arr
        else indexArray (add ix 1) arr
      )
  else arr

readDigit : Char -> < Err : () | Ok : Int >
readDigit c =
  case c of
    '0' -> Ok 0
    '1' -> Ok 1
    '2' -> Ok 2
    '3' -> Ok 3
    '4' -> Ok 4
    '5' -> Ok 5
    '6' -> Ok 6
    '7' -> Ok 7
    '8' -> Ok 8
    '9' -> Ok 9
    _ -> Err ()

readInt : String -> < Err : () | Ok : Int >
readInt str =
  if eqString "" str
  then Err ()
  else
    foldlString
      (\acc el ->
        case acc of
          Err err -> Err err
          Ok val ->
            case readDigit el of
              Err err -> Err err
              Ok n -> Ok (add (multiply 10 val) n)
      )
      (Ok 0)
      str

parseCommand :
  String ->
  < Quit : ()
  | Help : ()
  | Add : String
  | List : ()
  | Delete : Int
  | Invalid : String
  >
parseCommand line =
  let stripped = strip line in
  let lines = splitString ' ' stripped in
  if and (eqInt (lengthArray lines) 1) (eqString (indexArray 0 lines) "quit") then Quit ()
  else if and (eqInt (lengthArray lines) 1) (eqString (indexArray 0 lines) "help") then Help ()
  else if and (eqInt (lengthArray lines) 1) (eqString (indexArray 0 lines) "list") then List ()
  else if and (eqInt (lengthArray lines) 2) (eqString (indexArray 0 lines) "add") then Add (indexArray 1 lines)
  else if and (eqInt (lengthArray lines) 2) (eqString (indexArray 0 lines) "delete") then
    case readInt (indexArray 1 lines) of
      Err err -> Invalid stripped
      Ok n -> Delete n
  else Invalid stripped

writeTodos : Array String -> IO ()
writeTodos todos =
  if eqArray eqString [] todos
  then writeStdout stdout (toUtf8 "nothing to do\n")
  else
    foldlArray
      (\acc todo ->
        comp
          acc
          writeStdout stdout (toUtf8 "$todo\n")
      )
      (pureIO ())
      todos

runCommand :
  < Quit : () | Help : () | Add : String | List : () | Delete : Int | Invalid : String > ->
  Array String ->
  IO < Continue : Array String | Quit : () >
runCommand cmd todos =
  case cmd of
    Quit x ->
      pureIO (Quit ())
    Help x -> 
      comp
        writeStdout stdout (toUtf8 "help - display this message\n")
        writeStdout stdout (toUtf8 "quit - exit the application\n")
        writeStdout stdout (toUtf8 "list - display the todolist\n")
        writeStdout stdout (toUtf8 "add STRING - add a task to the list\n")
        writeStdout stdout (toUtf8 "delete INT - delete a task from the list\n")
        return (Continue todos)
    Add todo ->
      pureIO (Continue (snocArray todos todo))
    List x ->
      mapIO
        (\_ -> Continue todos)
        (writeTodos todos)
    Invalid x ->
      mapIO
        (\_ -> Continue todos)
        (writeStdout stdout (toUtf8 "error: invalid command \"$x\"\n"))
    Delete ix ->
      pureIO (Continue (deleteAt ix todos))

loop : Array String -> IO ()
loop todos = 
  comp
    writeStdout stdout (toUtf8 "> ") 
    flushStdout stdout
    bind line <- readLineStdin stdin
    bind next <- runCommand (parseCommand line) todos
    case next of
      Continue newTodos -> loop newTodos
      Quit x -> pureIO ()

main : IO ()
main = 
  comp
    writeStdout stdout (toUtf8 "Welcome to your TODO list\n")
    loop []